=head1 Einführung in I<Instant Messaging> mit AnyEvent::XMPP (Jabber)

Eine Einführung in das Perl Modul L<AnyEvent::XMPP> und wie man damit
I<Instant Messages> verschickt und empfängt.

=head2 Autor

Robin Redeker C<<elmex@ta-sa.org>>

=head2 Bio Robin Redeker

Ich Studiere Informatik an der Uni Karlsruhe im 7. Semester und
arbeite seit ca. 6 Jahren mit Perl.

=head2 Abstract

Dieser Artikel soll eine kurze Einführung in L<AnyEvent::XMPP>
geben. Angefangen bei einer kurzen Einführung in XMPP selbst,
geht es weiter mit einem Überblick über das Perl Modul L<AnyEvent::XMPP>.
Danach wird kurz das Eventmodell erläutert und am Ende ist dann ein
ausführlich kommentiertes Beispiel-Script zu finden.

=head2 Instant Messaging

X<Instant Messaging>I<Instant Messaging> ist der Begriff für (nahezu)
Echtzeit-Kommunikation in Form von Text-Nachrichten zwischen zwei oder mehr
Personen. Dabei wird die Nachricht üblicherweise übers Internet verschickt.

Hier ein Überblick über ein paar I<Instant Messaging> Protokolle:

=over 4

=item * Proprieatäre Protokolle:

ICQ, AIM, MSN

=item * Offene Protokolle:

UNIX talk, BITNET, IRC, PSYC, SIMPLE (Ein von der IETF auf SIP basierendes
Instant Messaging Protokoll), XMPP, u.a.

=back

=head2 XMPP (aka Jabber)

Historie:

=over 4

=item *

Jabber wurde 1999 von Jeremy Miller entwickelt.

=item *

Später (2002) wurde Jabber dann von der Jabber Software Foundation
(Seit 2007 heißt diese XMPP Standards Foundation) als RFC in die IETF gepusht.

=item *

Das Jabber Protokoll wurde umbenannt in X<XMPP>XMPP (Extensible Messaging and Presence
Protocol) und in 2 RFCs aufgespalten: RFC 3920 & 3921 (Sowie die weniger
relevanten RFCs 3922 und 3923).

=back

Was es macht:

=over 4

=item * XMPP ist ein Protkoll zum austausch von Präsenz-Informationen
("Bin da", "Bin kurz weg", "Bin nicht da") sowie zum Austausch
von (meist kurzen) Nachrichten.

=item * Es gibt viele kleine erweiterungs Protokolle, die XEPs (XMPP Extension Protocols),
die beispielsweise weitere Funktionalitäten definieren wie z.b. Chaträume,
Dateitransfer, und andere kleine Gimmicks wie z.b. Avatare (kleine Bildchen die in den
Clicki-Bunti-Clients von anderen angezeigt werden).

=back

=head2 Architektur von XMPP

=over 4

=item * Kontakte im XMPP Netzwerk haben eine JID, die ca. so aussieht wie eine
E-Mail Addresse. z.B.: C<elmex@jabber.org>

=item * Server können von jedermann aufgesetzt werden. Man kann also entweder
seinen eigenen Server unterhalten oder man sucht sich einen kostenlosen
Server (z.B. über eine auf jabber.org zu findende Liste von).

Die JID des Accounts ergibt sich dann aus C<name@domain.tld>. Also z.B. C<elmex@jabber.org>.

Alle Daten die dann zum Account gehören (Kontaktlisten, etc.) werden
auf dem Server gespeichert.

=item * Nachrichten zwischen zwei Clients im XMPP Netzwerk legen folgenden Weg zurück:

   Client <-> Server <-> Server <-> Client

Also: Clients connecten zum Server zu einem bestimmten Account (Meist JID + Passwort
für Authentifizierung nötig). Wenn dann der Client eine Nachricht sendet an einen
User auf einem anderen Server, bauen die Server untereinander Verbindugen
auf zum Übertragen der Nachricht.

=item * Komponenten können spezielle Funktionalitäten implementieren und
mit Servern verbunden werden, und geniessen dabei etwas mehr Zugriffsrechte als
ein normaler Client.
Bestes Beispiel hierfür sind I<Chaträume> die bei XMPP/Jabber eher als
I<after-thought> dazu gehackt wurden.

=item * Die Verbindungen zwischen den Servern und zwischen Client und Server werden
(auf Protokollebene) 'XML Stream' genannt. Dort werden sogenannte 'XML Stanzas',
XML Fragmente, hin und her geschickt. Es wird ein Stream-Parser benötigt, wie
z.b. expat, um mit diesem XML umgehen zu können.

=back

=head2 AnyEvent::XMPP Überblick

=over 4

=item * L<AnyEvent::XMPP> ist ein Perl Modul zum Entwickeln von XMPP Clienten und Komponenten.

=item * Es nimmt einem die ganzen Kopfschmerzen ab, wie z.b. man den 'XML Stream'
zum Server aufbaut, Nachrichten verschickt und Präsenz-Informationen und
die Kontaktliste (bei XMPP 'Roster' genannt) verwaltet.

=item * Dazu implementiert L<AnyEvent::XMPP> ein paar wichtige XEPs ohne die man keinen
ernsthaften IM Clienten der auf XMPP basiert entwickeln könnte.

=back

=head2 Die 2 in AnyEvent::XMPP

=over 4

=item * Alternativen wie L<Net::XMPP>, L<Net::Jabber> und L<Jabber::Lite> sind teilweise
veraltet und erlauben auch oft nur schwer oder gar keine Event-basierte Programmierung.
Dort müsste man dann auf Threads zurückgreifen um noch sinnvoll andere Dinge tun zu
können, wie z.B. eine GUI steuern.

=over 4

=item - Jabber::Lite

  - kein UTF-8 Support
  - nicht Event basiert, man braucht Threads um noch Dinge
    ausser XMPP zu machen
  - man muss das meiste selbst machen (Roster Verwaltung, etc.)

=item - Net::Jabber

  - auch nicht Event basiert

=item - Net::XMPP

  - Sehr ähnlich zu Net::Jabber und hat die selben Probleme

=item * L<AnyEvent::XMPP> hab ich geschrieben um:

=over 4

=item * Ohne Threads auszukommen und es einfacher zu haben Event-basiert zu arbeiten.

=item * Die Aktuellen XMPP RFCs umzusetzen.

=item * Mit sovielen XMPP Servern interoperabel zu sein wie möglich.  Vor allem ältere
XMPP Server, unterstützen teilweise nur alte, teilweise nicht spezifizierte
Authentifizierungs-Protokolle.

=back

=back

=head2 Abhängigkeiten von AnyEvent::XMPP

L<AnyEvent::XMPP> hat einige Abhängigkeiten um XMPP standardkonform zu implementieren:

  AnyEvent            - Um dem User von AnyEvent::XMPP die Event-Loop Wahl zu überlassen
  XML::Writer         - Um "XML" auszugeben
  XML::Parser::Expat  - Um mit dem "XML", wie XMPP es definiert, umzugehen
  Net::SSLeay         - Um TLS Verbindungen aufzubauen zu XMPP Servern
  Net::DNS            - Um DNS SRV Records für XMPP Servern abzufragen
  Net::LibIDN         - Um JIDs zu normalisieren (mit stringprep).
  Authen::SASL        - Für die SASL Authentifizierung mit dem XMPP Server

Und noch ein paar andere wie: L<Digest::SHA1>, L<MIME::Base64>.

Das sind leider ziemlich viele Abhängigkeiten die auch zum Teil C-Bibliotheken
benötigen, allerdings sind all diese Technologien (TLS, SASL, LibIDN, DNS, ...)
notwendig für eine brauchbare XMPP Implementation.

An dieser Stelle möchte ich auch nochmal auf die Verwendung von L<AnyEvent>
hinweisen. L<AnyEvent> erlaubt dem Benutzer von L<AnyEvent::XMPP> die Event-Loop zu
wählen, von der die I/O Events kommen. Das heisst L<AnyEvent::XMPP> ist einfach
integrierbar in eine Applikation die bereits Gtk2, Tk, Glib, Event oder eine
andere von AnyEvent unterstützte Event-Loop benutzt.

=back

=head2 AnyEvent::XMPP Module

L<AnyEvent::XMPP> enthält noch eine Reihe anderer (Unter-)Module.
Davon implementieren viele eher optionale Funktionalität.

Die wichtigsten und grundlegendsten Module in L<AnyEvent::XMPP> sind hier
aufgelistet:

=over 4

=item AnyEvent::XMPP::Event

Das Eventmodell von L<AnyEvent::XMPP>, auf welches ich im nächsten Abschnitt eingehen
werde.

=item AnyEvent::XMPP::Connection

Repräsentiert einen rohen "XML Stream" ohne weitere "Instant Messaging" Funktionalität.

Meistens wird man allerdings L<AnyEvent::XMPP::IM::Connection> oder L<AnyEvent::XMPP::Client>
verwenden wollen, die in den nächsten zwei Punkten beschrieben werden.

=item AnyEvent::XMPP::IM::Connection

Ist von L<AnyEvent::XMPP::Connection> abgeleitet und erweitert diese um I<Instant Messaging>
Funktionalität wie z.b. Präsenz-Status setzen, Präsenz von Kontakten empfangen
sowie Kontaktlisten-(/Roster-)Management.

=item AnyEvent::XMPP::Client

Implementiert einen einfachen XMPP Client der sich mit mehreren Accounts
gleichzeitig verbinden kann und die L<AnyEvent::XMPP::IM::Connection> Objekte für
einen verwaltet.

=item AnyEvent::XMPP::IM::Message

Ein Objekt dieser Klasse repräsentiert eine XMPP Nachricht. Die wohl wichtigsten
Methoden sind C<to>, C<from> und C<any_body> um auf Absender, Empfänger und den
Inhalt der Nachricht zugreifen zu können.

=back

Für nähere Information zu den Modulen bitte ich die jeweilige POD Dokumentation
aufzusuchen.

=head2 Events in AnyEvent::XMPP

Ich habe eine relativ einfaches Eventmodell für L<AnyEvent::XMPP> implementiert.
L<AnyEvent::XMPP::Connection> ist von L<AnyEvent::XMPP::Event> abgeleitet und erbt
unter anderen die folgenden Methoden:

=over 4

=item reg_cb ($event1, $cb1, ...)

Um bestimmte Events, die in der Dokumentation beschrieben sind zu empfangen,
muss man einen Callback mit C<reg_cb> registrieren. Wenn man zum Beispiel den
C<session_ready> Event von L<AnyEvent::XMPP::IM::Connection> bekommen möchte
(der geschickt wird wenn man authentifiziert ist und Nachrichten verschicken kann),
macht man ungefähr dies:

   my $con = AnyEvent::XMPP::IM::Connection->new (...);
   ...
   $con->reg_cb (session_ready => sub {
      my ($con) = @_;
      ...
   });

Oder, für Leute die Closures nicht so mögen:

   sub session_ready_cb {
      my ($con) = @_;
   }
   ...
   $con->reg_cb (session_ready => \&session_ready_cb);

Man kann übrigens mehrere Callbacks für einen Event registrieren,
diese werden dann in der Reihenfolge, in der sie registriert wurden, aufgerufen
wenn der Event ausgelöst wird.

=item unreg_cb ($regid)

Das Returnvalue von C<reg_cb> ist übrigens eine ID, die man für die C<unreg_cb>
Methode braucht um die Events wieder abzubestellen:

   my $regid =
      $con->reg_cb (
         eventname1 => sub { ... },
         eventname2 => sub { ... },
         ...
      );
   ...
   $con->unreg_cb ($regid); # unregistriert die vom obigen reg_cb registrierten
                            # event callbacks.

=item unreg_me

Wenn man sich innerhalb eines Callbacks befindet und beschliesst, dass man diesen
unregistrieren will kann man folgendes machen:

   $con->reg_cb (
      event_xyz => sub {
         my ($con) = @_;
         ...
         $con->unreg_me;
         ...
      }
   );

Die Methode C<unreg_me> sorgt dafür das der registrierte und gerade aufgerufene
Callback entfernt wird.

=item event ($eventname, @args)

Diese Methode kann man benutzen um eigene Events auszulösen. Dabei sollte man allerdings
vermeiden von L<AnyEvent::XMPP> verwendete Events zu benutzen, da dies zu Fehlern führen
könnte. Das erste Argument ist der Name des Events den man auslösen möchte
und die C<@args> werden später den Callbacks übergeben.

Das Ganze sieht ca. so aus:

   $con->reg_cb (
      mein_test_event => sub {
         my ($con, $str) = @_;
         print "mein_test_event ausgelöst mit erstem argument: $str\n";
      }
   );
   $con->event (mein_test_event => "argument1");

Gibt folgendes aus:

   mein_test_event ausgelöst mit erstem argument: argument1

=item set_exception_cb ($cb)

Wenn man einmal in einer Methode einen Fehler macht und eine Exception
geworfen wird, dann wird diese von L<AnyEvent::XMPP::Event> abgefangen und ausgegeben.
Die Ausgabe kann man dann mit C<set_exception_cb> abfangen und selbst machen:

   $con->set_exception_cb (sub {
      my ($exception) = @_;
      warn "Exception in event processing: $exception\n";
   });

=back

Es gibt noch eine Reihe weiterer interessanter Methoden, die ich hier nicht erläutern
werde. Bei Interesse diese bitte in der Dokumentation von L<AnyEvent::XMPP::Event> nachlesen.

=head2 Beispiel

Als Abschluss möchte ich noch ein ausführlich dokumentiertes
Beispiel bringen, welches eine Nachricht an jemanden verschickt:

 #!/opt/perl/bin/perl
 use strict;
 use AnyEvent;
 use AnyEvent::XMPP::IM::Connection;
 
 unless (@ARGV >= 3) { die "sendmsg <account jid> <password> <destination jid>\n" }
 
 my $msg  = do { local $/; <STDIN> };  # Die Nachricht zum Schicken
 my $dest = $ARGV[2];                  # Das Ziel der Nachricht
 
 my $j = AnyEvent->condvar; # Wird später für die Event-Loop gebraucht
 
 # Wir erzeugen erstmal ein neues Verbindungsobjekt:
 my $con =
    AnyEvent::XMPP::IM::Connection->new (
       jid      => $ARGV[0],    # Die JID von _unserem_ Account
       password => $ARGV[1],    # Das Passwort für _unseren_ Account
       initial_presence => -10, # Die initiale Präsenz-Priorität, eine negative
                                # Priorität heisst, dass wir keinerlei auf dem Server
                                # gespeicherten Nachrichten empfangen wollen.
    );
 
 # Dann registrieren wir ein paar Callbacks:
 $con->reg_cb (
    # Dieser Event wird ausgelöst, wenn wir erfolgreich mit dem XMPP
    # Server verbunden wurden:
    session_ready => sub {
       my ($con) = @_;
       print "Connected as " . $con->jid . "\n"; # Gibt die JID für diese Session aus
       print "Sending message to $dest:\n$msg\n";
 
       # Wir verpacken die Nachricht, die wir schicken wollen:
       my $immsg = AnyEvent::XMPP::IM::Message->new (to => $dest, body => $msg);
 
       # Und schicken sie über die Verbindung zum Server:
       $immsg->send ($con);
    },
 
    # Wenn jemand eine Nachricht an uns geschickt hat
    # wird dieser Callback aufgerufen:
    message => sub {
       my ($con, $msg) = @_;
 
       # $msg ist ein AnyEvent::XMPP::IM::Message Objekt, von welchem wir hier
       # das Wissenswerte ausgeben:
       print "Message from " . $msg->from . ":\n" . $msg->any_body . "\n---\n";
    },
 
    # Wenn irgendein Fehler auftritt wird dieser Event aufgerufen,
    # mit einem Fehler-Objekt, welches uns mehr über den Fehler sagen kann:
    error => sub {
       my ($con, $error) = @_;
       warn "Error: " . $error->string . "\n"; # Die ->string Methode gibt einen
                                               # human-readable String zurück
    },
 
    # Sollte es aus irgendeinem Grund zum Verbindungsabbruch kommen wird dieser
    # Callback aufgerufen:
    disconnect => sub {
       my ($con, $h, $p, $reason) = @_;
       warn "Disconnected from $h:$p: $reason\n";
 
       $j->broadcast; # Hier wird die Event-Loop beendet, damit sich das Programm
                      # beenden kann
    }
 );
 
 # Und nach dem Callback-Registrieren bauen wir die TCP Verbindung auf
 # und setzen die Authentifizierung in Gang:
 print "Trying to connect...\n";
 $con->connect ();
 
 # Nach dem Initieren der Verbindung wollen wir nun auf I/O Events warten
 # und starten die Event-Loop:
 $j->wait;
 # Hier gehts weiter wenn $j->broadcast aufgerufen wurde
 # (siehe Disconnect Callback oben).

=head2 Quellen / Referenzen

=over 4

=item XMPP

I<XMPP RFC3920 & RFC3921>, C<http://www.xmpp.org/rfcs/>

=back
