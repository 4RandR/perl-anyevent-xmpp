=cut

use utf8;

=head1 Einführung in "Instant Messaging" mit Net::XMPP2 (Jabber)

=head2 Was ist "Instant Messaging"

Wikipedia: "Instant messaging (IM) is a form of real-time communication
between two or more people based on typed text. The text is conveyed via
computers connected over a network such as the Internet."

   Klassische Protokolle:
      - UNIX talk, BITNET, IRC

   Proprieatäre Protokolle:
      - ICQ, AIM, MSN

   Offene IM Protokolle:
      - PSYC
      - SIMPLE (Ein von der IETF auf SIP basierendes Instant Messaging Protokoll)
      - XMPP
      - u.a.

=head2 Was ist XMPP (aka Jabber)?

Historie:

=over 4

=item *

Jabber wurde 1999 von Jeremy Miller entwickelt.

=item *

Später (2002) wurde Jabber dann von der Jabber Software Foundation
(Seit 2007 heißt diese XMPP Standards Foundation) als RFC in die IETF gepusht.

=item *

Das Jabber Protokoll wurde umbenannt in XMPP (Extensible Messaging and Presence
Protocol) und in 2 RFCs aufgespalten: RFC 3920 & 3921 (Sowie die weniger
relevanten RFCs 3922 und 3923).

=back

Was es macht:

=over 4

=item *

XMPP ist ein Protkoll zum austausch von Präsenz-Informationen
("Bin da", "Bin kurz weg", "Bin nicht da") sowie zum austausch
von (meist kurzen) Nachrichten.

=item *

Es gibt viele kleine erweiterungs Protokolle, die XEPs (XMPP Extension Protocols),
die beispielsweise weitere Funktionalitäten definieren wie z.b. Chaträume,
Dateitransfer, und andere kleine Gimmicks wie z.b. Avatare (Kleine Bildchen die in den
Clicki-Bunti-Clients von anderen angezeigt werden).

=back

=head2 Architektur von XMPP

=over 4

=item *

Kontakte im XMPP Netzwerk haben eine JID, die ca. so aussieht wie eine
E-Mail Addresse. z.B.: C<elmex@jabber.org>

=item *

Server können von jedermann aufgesetzt werden. Man kann also entweder
seinen eigenen Server unterhalten oder man sucht sich einen kostenlosen
Server (z.b. ueber eine auf jabber.org zu findende Liste von).

Die JID des Accounts ergibt sich dann aus C<name@domain.tld>. Also z.B. C<elmex@jabber.org>.

Alle Daten die dann zum Account gehören (Kontaktlisten, etc.) werden
auf dem Server gespeichert.

=item *

Nachrichten zwischen zwei Clients im XMPP Netzwerk legen folgenden Weg zurück:

   Client <-> Server <-> Server <-> Client

Also: Clients connecten zum Server zu einem bestimmten Account (Meist JID + passwort
für Authentifizierung nötig). Wenn dann der Client eine Nachricht sendet an einen
User auf einem anderen Server, bauen die Server untereinander Verbindugen
auf zum übertragen der Nachricht.

=item *

Komponenten können spezielle Funktionalitäten implementieren und
mit Servern verbunden werden, und geniessen dabei etwas mehr Zugriffsrechte als
ein normaler Client.
Bestes Beispiel hierfür sind "Chaträume" die bei XMPP/Jabber eher als
"after-thought" dazu gehackt wurden.

=item *

Die Verbindungen zwischen den Servern und zwischen Client und Server werden
(auf Protokollebene) 'XML Stream' genannt. Dort werden sogenannte 'XML Stanzas',
XML Fragmente, hin und her geschickt. Es wird ein XML-Stream-Parser benötigt, wie
z.b. expat, um mit diesem XML umgehen zu können.

=back

=head2 Was Net::XMPP2 macht/ist

=over 4

=item *

L<Net::XMPP2> ist ein Perl Modul zum entwickeln von XMPP Clienten und Komponenten.

=item *

Es nimmt einem die ganzen Kopfschmerzen ab, wie z.b. man den 'XML stream'
zum Server aufbaut, Nachrichten verschickt und Präsenz-Informationen und
die Kontaktliste (bei XMPP 'Roster' genannt) verwaltet.

=item *

Dazu implementiert L<Net::XMPP2> ein paar wichtige XEPs ohne die man keinen
ernsthaften IM Clienten der auf XMPP basiert entwickeln könnte.

=back

=head2 Warum die 2 in Net::XMPP2?

=over 4

=item *

Alternativen wie L<Net::XMPP>, L<Net::Jabber> und L<Jabber::Lite> sind teilweise
veraltet und erlauben auch oft nur schwer oder garkeine Event-basierte Programmierung.
Man muss dann auf Threads zurückgreifen.

  - Jabber::Lite
    - kein UTF-8 support
    - nicht Event basiert, man braucht Threads um noch dinge
      ausser XMPP zu machen
    - man muss das meiste selbst machen (Roster verwaltung, etc.)
  - Net::Jabber
    - auch nicht Event basiert
  - Net::XMPP sehr ähnlich zu Net::Jabber und hat die selben
    Probleme

=item *

L<Net::XMPP2> hab ich geschrieben um:

=over 4

=item *

Ohne Threads auszukommen und es einfacher zu haben Event-basiert zu arbeiten.

=item *

Die Aktuellen XMPP RFCs umzusetzen.

=item *

Mit sovielen XMPP Servern interoperabel zu sein wie möglich.  Vorallem ältere
XMPP Server, unterstützen teilweise nur alte, teilweise nicht spezifizierte,
Authentifizierungs-Protokolle.

=back

=back

=head2 Dependencies von Net::XMPP2

L<Net::XMPP2> hat einige Abhängigkeiten um XMPP standardkonform zu implementieren:

  AnyEvent            - Um dem User von Net::XMPP2 die Event-loop Wahl zu überlassen
  XML::Writer         - Um "XML" auszugeben
  XML::Parser::Expat  - Um mit dem "XML", wie XMPP es definiert, umzugehen
  Net::SSLeay         - Um TLS Verbindungen aufzubauen zu XMPP Servern
  Net::DNS            - Um DNS SRV Records für XMPP Servern abzufragen
  Net::LibIDN         - Um JIDs zu normalisieren (mit stringprep).
  Authen::SASL        - Für die SASL Authentifizierung mit dem XMPP Server

Und noch ein paar andere wie: L<Digest::SHA1>, L<MIME::Base64>.

Das sind leider ziemlich viele Abhängigkeiten die auch zum teil C-Bibliotheken
benötigen, allerdings sind all diese Technologien (TLS, SASL, LibIDN, DNS, ...)
notwendig für eine brauchbare XMPP Implementation.

An dieser Stelle möchte ich auch nochmal auf die Verwendung von L<AnyEvent>
hinweisen. L<AnyEvent> erlaubt dem Benutzer von L<Net::XMPP2> die Event-loop zu
wählen, von der die I/O events kommen. Das heisst L<Net::XMPP2> ist einfach
integrierbar in eine Applikation die bereits Gtk2, Tk, Glib, Event oder eine
andere von AnyEvent unterstützte Event-loop benutzt.

=back

=head2 Überblick über Net::XMPP2

Die wichtigsten Module in L<Net::XMPP2> sind:

=over 4

=item Net::XMPP2::Event

Das Eventmodell von L<Net::XMPP2>, auf welches ich im nächsten Abschnitt eingehen
werde.

=item Net::XMPP2::Connection

Repräsentiert einen rohen "XML Stream" ohne weitere "Instant Messaging" Funktionalität.

Meistens wird man allerdings L<Net::XMPP2::IM::Connection> oder L<Net::XMPP2::Client>
verwenden wollen, die in den nächsten zwei Punkten beschrieben werden.

# TODO: Wie benutzt man sie?

=item Net::XMPP2::IM::Connection

Ist von L<Net::XMPP2::Connection> abgeleitet und erweitert diese um "Instant Messaging"
Funktionalität wie z.b. Präsenz-Status setzen, Präsenz von Kontakten empfangen
sowie Kontaktlisten-(/Roster-)Management.

# TODO: siehe oben

=item Net::XMPP2::Client

Implementiert einen einfachen XMPP Client der sich mit mehreren Accounts
gleichzeitig verbinden kann und die L<Net::XMPP2::IM::Connection> Objekte für
einen verwaltet.

# TODO: Benutzung egal für vortrag

=item Net::XMPP2::IM::Message

Ein Objekt dieser Klasse repräsentiert eine XMPP Nachricht. Die wohl wichtigsten
Methoden sind C<to>, C<from> und C<any_body> um auf Absender, Empfänger und den
Inhalt der Nachricht zugreifen zu können.

# TODO: Benutzung

=back

Für nähere Information zu den Modulen bitte ich die jeweilige POD Dokumentation
aufzusuchen.

=head2 Events in Net::XMPP2

Ich habe eine relativ einfaches Eventmodell für L<Net::XMPP2> implementiert.
L<Net::XMPP2::Connection> ist von L<Net::XMPP2::Event> abgeleitet und erbt
vom dem unter anderem die folgenden Methoden:

=over 4

=item reg_cb ($event1, $cb1, ...)

Um bestimmte events die in der Dokumentation beschrieben sind zu empfangen
muss man einen Callback mit C<reg_cb> registrieren. Wenn man zum Beispiel den
C<session_ready> Event von L<Net::XMPP2::IM::Connection> bekommen möchte
(der geschickt wird wenn man authentifiziert ist und Nachrichten verschicken kann)
macht man ungefähr dies:

   my $con = Net::XMPP2::IM::Connection->new (...);
   ...
   $con->reg_cb (session_ready => sub {
      my ($con) = @_;
      ...
   });

Oder, für Leute die Closures nicht so mögen:

   sub session_ready_cb {
      my ($con) = @_;
   }
   ...
   $con->reg_cb (session_ready => \&session_ready_cb);

Man kann überigends mehrere Callbacks für einen Event registrieren,
diese werden dann in der Reihenfolge, in der sie Registriert wurden, aufgerufen
wenn der Event ausgelöst wird.

=item unreg_cb ($regid)

Das Returnvalue von C<reg_cb> ist überigends eine ID die man für die C<unreg_cb>
Methode braucht um die Events wieder abzubestellen:

   my $regid =
      $con->reg_cb (
         eventname1 => sub { ... },
         eventname2 => sub { ... },
         ...
      );
   ...
   $con->unreg_cb ($regid); # unregistriert die vom obigen reg_cb registrierten
                            # event callbacks.

=item unreg_me

Wenn man sich innerhalb eines Callbacks befindet und beschliesst das man diesen
unregistrieren will kann man folgendes machen:

   $con->reg_cb (
      event_xyz => sub {
         my ($con) = @_;
         ...
         $con->unreg_me;
         ...
      }
   );

Die Methode C<unreg_me> sorgt dafür das der registrierte und gerade aufgerufene
Callback entfernt wird.

=item event ($eventname, @args)

Diese Methode kann man benutzen um eigene Events auszulösen. Dabei sollte man allerdings
vermeiden von L<Net::XMPP2> verwendete Events zu benutzen, da dies zu Fehlern führen
könnte. Das erste Argument ist der Name des Events den man auslösen möchte
und die C<@args> werden später den Callbacks übergeben.

Das ganze sieht ca. so aus:

   $con->reg_cb (
      mein_test_event => sub {
         my ($con, $str) = @_;
         print "mein_test_event ausgelöst mit erstem argument: $str\n";
      }
   );
   $con->event (mein_test_event => "argument1");

Gibt folgendes aus:

   mein_test_event ausgelöst mit erstem argument: argument1

=item set_exception_cb ($cb)

Wenn man einmal in einer Methode einen Fehler macht und eine Exception
geworfen wird, dann wird diese von L<Net::XMPP2::Event> abgefangen und ausgegeben.
Die Ausgabe kann man dann mit C<set_exception_cb> abfangen und selbst machen:

   $con->set_exception_cb (sub {
      my ($exception) = @_;
      warn "Exception in event processing: $exception\n";
   });

=back

Es gibt noch eine Reihe weiterer interessanter Methoden die ich (bei Interesse)
bitte in der Dokumentation von L<Net::XMPP2::Event> nachzulesen.

=head2 Beispiel

Als Abschluss möchte ich noch ein ausführlich Dokumentiertes
Beispiel bringen, welches eine Nachricht an jemanden verschickt:

   #!/opt/perl/bin/perl
   use strict;
   use AnyEvent;
   use Net::XMPP2::IM::Connection;

   unless (@ARGV >= 3) { die "sendmsg <account jid> <password> <destination jid>\n" }

   my $msg  = do { local $/; <STDIN> };  # Die Nachricht zum schicken
   my $dest = $ARGV[2];                  # Das Ziel der nachricht

   my $j = AnyEvent->condvar; # Wird später für die Event-loop gebraucht

   # Wir erzeugen erstmal ein neues Verbindungsobjekt:
   my $con =
      Net::XMPP2::IM::Connection->new (
         jid      => $ARGV[0],    # Die JID von _unserem_ account
         password => $ARGV[1],    # Das Passwort für _unseren_ account
         initial_presence => -10, # Die initiale Präsenz-Priorität, eine negative
                                  # Priorität heisst das wir keinerlei auf dem Server
                                  # gespeicherten Nachrichten empfangen wollen.
      );

   # Dann registrieren wir ein paar Callbacks:
   $con->reg_cb (
      # Dieser Event wird ausgelöst wenn wir erfolgreich mit dem XMPP
      # Server verbunden wurden:
      session_ready => sub {
         my ($con) = @_;
         print "Connected as " . $con->jid . "\n"; # Gibt die JID für diese session aus
         print "Sending message to $dest:\n$msg\n";

         # Wir verpacken die Nachricht die wir schicken wollen:
         my $immsg = Net::XMPP2::IM::Message->new (to => $dest, body => $msg);

         # Und schicken sie über die Verbindung zum server:
         $immsg->send ($con);
      },

      # Wenn jemand eine Nachricht an uns geschickt hat
      # wird dieser Callback aufgerufen:
      message => sub {
         my ($con, $msg) = @_;

         # $msg ist ein Net::XMPP2::IM::Message objekt, von welchem wir hier
         # das wissenswerte ausgeben:
         print "Message from " . $msg->from . ":\n" . $msg->any_body . "\n---\n";
      },

      # Wenn irgendein Fehler auftritt wird dieser Event aufgerufen,
      # mit einem Fehler-objekt welches uns mehr über den Fehler sagen kann:
      error => sub {
         my ($con, $error) = @_;
         warn "Error: " . $error->string . "\n"; # Die ->string Methode gibt einen
                                                 # human-readable String zurück
      },

      # Sollte es aus irgendeinem Grund zum Verbindungsabbruch kommen wird dieser
      # Callback aufgerufen:
      disconnect => sub {
         my ($con, $h, $p, $reason) = @_;
         warn "Disconnected from $h:$p: $reason\n";

         $j->broadcast; # Hier wird die Event-Loop beendet, damit sich das Programm
                        # beenden kann
      }
   );

   # Und nach dem Callback-Registrieren bauen wir die TCP Verbindung auf
   # und setzen die Authentifizierung in gang:
   print "Trying to connect...\n";
   $con->connect ();

   # Nach dem initieren der Verbindung wollen wir nun auf I/O Events warten
   # und starten die Event-Loop:
   $j->wait;
   # Hier gehts weiter wenn $j->broadcast aufgerufen wurde
   # (siehe disconnect Callback oben).
